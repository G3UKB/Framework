(* 
	gen_server.8th
 
  A general purpose server to be used for all tasks that require the
  messaging infrastructure.
 
 Copyright C 2019 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
     
  
  This module is loosly based on the erlang gen-server in that it emulates a 
	process oriented message passing concurrency model.
		
	This is part of the generic framework in the namespace fr.*
	
  PUBLIC INTERFACE:
  Main words for gen-server and message management:
  
  Create a new gen-server with the task name s. As everything is performed using the task name you should
  never need to get the task ref.
  
  	gen_server_new	SED: s --
  	
  Ask the gen-server with task name s to terminate. The server is designed to always allow proper termination.
  
  	gen_server_term SED: s --
  	
  Send a message to the gen-server with task name s, calling word w with the opaque data *. The opaque data can be
  any as it is passed directly to w. However, if a response is required the convention is [*, sender, w] where *
  is the opaque data and the sender is the task name to send the response to and w is the word to call [see later].
  
  	msg! SED: s w * --
  
  Retrieve message for tasks that are not gen-servers. Returns only data content.
  	msg@ SED: -- *
  	
  Retrieve message for tasks that are not gen-servers. Returns the whole message which includes response info.
  	msg@@ SED: -- *
  	
  A helper which will add the senders task name and word to call to the end of the array a, returning the new array.
  	+sender SED: a w -- a
  
  When the word w receives a message from msg! it must be aware of the structure of the opaque data and if a response
  is required the array must include the sender name and word to call. In order to respond it should call response! 
  with the sender name s, w|null the word to call with the response data and * the opaque response data.
  
  	response!	SED: s w * --
  
  Retrieve a response to a message for non-gen-server tasks.
  	
  	response@	SED: -- 
  
  Additional words for task registration and other utility actions:
  If a task which is NOT a gen-server wishes to participate in the messaging framework it must be registered in the task registry
  with t the task reference and s the task name.
  
  	reg!	SED: t s --
  
  Remove a registration.
  
  	reg_rm SED: s -- t
  	
  When it is required to terminate one or all tasks gen_server_term is used to terminate each task. However it is good practice 
  to wait for the task to exit.
  
  wait_single_task SED: s --
  Wait_all SED: --
 
 Messaging scenarios
 ===================
 There are quite a number of sender/receiver combinations that require specific protocols. These are pretty much the same
 whether messaging is direct through the gen-server or through the pub/sub system which dispatches through gen-server.
 However, the pub-sub system should be used for all communication unless there is a reason for not doing so. 
 
 1. Sender : gen-server, receiver : gen-server. 
 		This is the simplest scenario as everything is managed by the gen-server. Messages are sent using msg!. If a response
 		task and word is included in the message then the response is automatically sent to the task. Note that both sending and
 		receiving are dispatched via the task-q so always arrive on the thread of the appropriate task. This is also true if 
 		messages are sent via pub/sub. This provides complete isolation between tasks.
 2. Sender : gen-server, receiver : normal user task.
 		In this case the normal user task must be registered using reg! so its task object can be retrieved by task name. Sending is 
 		the same as before using msg!. However, the receiver is not going to get that message automatically because there is no
 		gen-server to take it from the q. Therefore the receiver maust call msg@ or msg@@ to retrieve messages. It must do this
 		on a regular basis. There is no return value from the call, either the receiver word is called if there is a message or
 		nothing happens. If a response is required then the receiver can simply use msg! and the sender will automatically get the response.
 3. Sender : normal user task, receiver gen-server.
 		This is similar to [2]. The sender uses msg! and the receiver automatically gets the message. If a response is required then sender
 		must use response@ as it will not automatically get the response. If it wants responses it must be registered.
 4.	Sender : gen-server, receiver : GUI task.
 		A GUI taks cannot read from its task q and any attempt to do so will cause a freeze. For this reason all communication with a
 		GUI task MUST use the pub/sub system. Gen-server does not distinguish between tasks. The pub/sub system takes a different path for
 		the main task [GUI, REPL and MAIN_TASK are considered the same]. For these it dispatches using g:do rather than through gen-server.
 		The g:do call automatically calls the word under the "cb" key so no action required nby the GUI task.
 5. Sender : GUI task, receiver : gen-server.
 		Again pub/sub should be used although direct calls will work. The sender publishes and the receiver [all subscribers] automatically 
 		receive the message.
 		
 A further word on pub/sub
 ==========================
 This is actually a very simple module. A subscriber subscribes to a topic and gives a task name and a word
 to call. If the topic is not present a new entry is started else the subscriber is added to the topic. When a message is published
 it is sent to all subscribers either using msg! or g:do as explained above. This means that a receiver does not know if the message
 was sent directly of via a publish, so it can contain the same reply information. If a reply word is set then the receiver can
 simply reply directly via msg!. This can be useful is some cases but beware of sending a reply to a GUI task! If a publisher has
 provided a reply word then if the sender was a gen-server it will be dispatched as normal but if it was a normal task then response@
 must be called to retrieve the response. HOWEVER, pub/sub in general should be used for send and forget traffic and if some response 
 is required then its better to have a separate pub/sub channel to respond on.
 
 Note that response@ is used quite a lot in the non-GUI module tests as in this case when the test is conducted from the main thread
 it can receive messages on its q. This is both for direct messaging and pub/sub messaging.

*)

\ ========================================
\ Testing only
false var, gen_server_test

\ ----------------------------------
gen_server_test @ #if
	\ Includes
	\ needs debug/sed
	\ true SED-CHECK
	\ needs debug/trace
	\ dbg:line-info
#then
\ ========================================

\ Set namespace
ns: fr.gs

\ ===============================================================================
\ ===============================================================================
\ PRIVATE
\ Convention: private words start __
\ ===============================================================================

\ ========================================
\ Task reference and termination management

\ Holder for task references
\ Global var, requires lock semantics
{} var, __task_dict

\ ----------------------------------
\ Locked var
: __gs_lock@
	__task_dict lock @ ;

\ ----------------------------------
\ Unlocked var	
: __gs_unlock
	__task_dict unlock drop ;
	
\ ----------------------------------
\ Is locked	
: __gs_islocked
	__task_dict locked? nip ;

\ ----------------------------------	
\ Store task referance
: __gs_reg!	SED: t s --
	\ in: 	o: s - task name
	\				1: t - task object
	\ out:	none
	__gs_lock@
	swap rot m:! drop 
	__gs_unlock ;

\ ----------------------------------	
\ Get task referance
: __gs_reg@	SED: s -- t
	\ in: 	0: s - task name
	\ out:	0: t - task ref
	__gs_lock@
	swap m:@ nip 
	__gs_unlock ;

\ ----------------------------------	
\ Remove task referance
: __gs_reg_rm	SED: s -- t
	\ in: 	0: s - task name
	\ out:	none
	__gs_lock@
	swap m:- nip 
	__gs_unlock ;

\ ----------------------------------
\ Wait for task to terminate
: __gs_wait_task SED: s t --
	\ in:		t - task ref 	(item from dict) 	
	\				s - task name (key from dict)
	\ out:	none
	swap dup 
	t:name@ s:= not if
		\ Not the calling task, can't wait for ourselves!
		"Waiting for task: %s" s:strfmt log 
		t:wait
	else
		2drop
	then
;

\ ----------------------------------
\ Terminate task
\ This is called from the task to terminate itself
\ It sets the run task var to false which is then tested within gen_server
: __gs_do_term  SED: a --
	\ in: 	0: []
	\ out:	none
	drop false t:name@ "_run" s:+ t:!
;

\ ========================================
\ GEN-SERVER

\ Task exceptions should come here so 'maybe' we will know which task failed.
: __handler	SED: x -- rc
	t:name@ "Task %s handler called with [%s]" s:strfmt log
	\ We may be able to handle some exceptions by restarting task.
	\ Return 0 which means invoke G:handler which will terminate the program.
	0
;

\ ----------------------------------
\ Process 1 item from task Q	
: __gs_proc_q	SED: --
	t:qlen 0 n:= if
		"Warning gen-server queue was empty when processing [" t:name@ s:+ "]!" s:+ log 
	else 
		t:pop null? if
			drop "Warning gen-server queue returned null [" t:name@ s:+ "]!" s:+ log
		else
			\ Message to process, just send data part
			"data" m:@ swap "cb" m:@ nip w:exec
		then
	then ;
	
\ ----------------------------------
\ Task entry point for all generic servers
: __gen_server	 SED: s t --
	\ in: 	0 t: calling task
	\				1 s: this task name
	\ out:	none
	\ Assign name and store in registry
	>r dup t:name! t:curtask swap __gs_reg!
	t:curtask log
	
	\ Set a task exception handler
	' __handler t:handler
	
	\ Set us in the run state using a task variable
	true t:name@ "_run" s:+ t:!
	
	\ Set q to return null on empty
	\ Note, should not happen
	t:getq false q:throwing drop
	\ Wake up calling thread which is waiting for us to finish initialisation
	r> t:notify
	\ We put 2 arbitrary items on stack. This allow us to check if the stack
	\ would cause an underflow which nearly always causes a crash and is therefore
	\ very hard to find.
	-1 -1 
	\ Set initial depth limit to 3 (T + underflow items)
	3 "depth" t:!
	\ Loop while run enabled
	repeat
		\ Wait for a wake up notify
		-1 t:q-wait
		' __gs_proc_q t:qlen
		\ Check q length
		\ dup 1 n:> if "Q: " . t:qlen . cr cr then 
		times
		\ Check for exit
		t:name@ "_run" s:+ t:@
		\ Check for stack growth problem, only the T value and underflow items should be on stack at this point.
		depth "depth" t:@ n:> if
			"Task " t:name@ s:+ " warning - data stack growing [" s:+ depth 2 n:- >s s:+ "]!" s:+ log
			depth "depth" t:!
		then
		\ Check for stack underflow problem, we should always have two items on the stack.
		depth 2 n:< if
			"Task " t:name@ s:+ " fatal - data stack would cause underflow [" s:+ depth 2 n:- >s s:+ "]!" s:+ throw
		then
	while!
	\ Exit message
	t:name@ " - exiting... [" s:+ depth >s s:+ "]" s:+ log ;

\ ===============================================================================
\ ===============================================================================
\ PUBLIC Call level Interface
\ ===============================================================================

\ Make a new server
: gen_server_new	SED: s -- 
	\ in: 	0 s: new task name
	\ out:	none
	\ Create the new task
	t:curtask 2 ' __gen_server t:task-n
	\ Wait for it to complete registration
	-1 sleep drop
;

\ ----------------------------------
\ Register an external task
: reg@	SED: s -- t
	__gs_reg@ 
;
	
\ ----------------------------------
\ Register an external task
: reg!	SED: t s --
	__gs_reg! 
;

\ ----------------------------------
\ Remove an external task
: reg_rm	SED: s -- t
	__gs_reg_rm 
;

\ ----------------------------------
\ Wait for task to terminate
: wait_single_task	SED: s --
	dup >r "Waiting for task: " swap s:+ log
	__gs_lock@
	r@ m:@ t:wait
	r> m:-
	__gs_unlock drop 
;

\ ----------------------------------
\ Wait for all tasks to terminate
: wait_all	SED: --
	__gs_lock@
	' __gs_wait_task m:each
	1 sleep
	__gs_unlock 2drop 
;

\ ========================================
\ Message management

\ ----------------------------------
\ Message send to a given word on a given task name queue
: msg!	SED: s w * --
	\ in:		* - opaque data to send 	
	\				w - word to invoke in task
	\				s - task name
	\ out:	none
	\ Word to invoke under the "cb" key and data under the "data" key
	\ The data is cloned before the send as it must be detached from the current task pool
	m:new "cb" 3 pick m:! "data" 2 pick m:! nip nip
	\ Clone the whole message structure and push to the task q
	const
	\ Get task for name and lock task-dict
	swap __gs_lock@ 
	swap m:@ nip
	\ Push message to task q
	dup rot t:push
	t:q-notify
	\ Release lock
	__gs_unlock drop
;

\ ----------------------------------
\ Add sender to message
: +sender	SED:	a w -- a
	\ in: 	0: w - word to call on response
	\				1: a - message array [*]
	\ out: 	0: a - [*, sender task name, w]
	swap t:name@ a:push swap a:push
;

\ ----------------------------------
\ Pull and execute from a task q else do nothing
\ Useful for non gen-server tasks which use pub/sub
: msg@	SED: -- *
	\ Check for a message
	t:qlen 0 n:> if 
		t:pop null? not if
			\ We have work
			\ Just send the data part of the message
			"data" m:@ 0 a:@ nip swap "cb" m:@ nip w:exec
		then
	then
;
\ As msg@ but return whole message
: msg@@	SED: -- *
	\ Check for a message
	t:qlen 0 n:> if 
		t:pop null? not if
			\ We have work
			\ Send the whole message which has the sender/word for responses
			"data" m:@ swap "cb" m:@ nip w:exec
		then
	then
;

\ ========================================
\ Response management

\ ----------------------------------
\ Get task response for synchronous send/response
: response@	SED: -- 
	\ in: 	none
	\ out: 	0: * - opaque response data
	\ Spin a while as we won't get a notify 
	100 repeat
		t:pop null? if
			\ Keep going
			drop n:1- 0.01 sleep
		else
			\ Data to process
			nip "data" m:@ swap "cb" m:@ nip w:exec ;;
		then
	while drop	
	"Timeout waiting for task response!" log
;

\ ----------------------------------
\ Push response data to sender
: __responder msg! ;
: response!	SED: s w * --
	\ in:		* - opaque data to send 	
	\				w - word to invoke in task
	\				s - task name
	\ out:	none
	\ We send response via a transient task otherwise we would deadlock
	const 3 ' __responder t:task-n t:wait
;

\ ========================================
\ Task termination
\ ----------------------------------
\ Ask task to terminate
: gen_server_term SED: s --
	\ We send an empty message to __gs_do_term which will self terminate
	' __gs_do_term a:new msg!
;

\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ ===============================================================================
\ Testing
\ ===============================================================================

gen_server_test @ #if
	with: fr.gs
	
	: set_q
		\ Must register REPL in the task repos to be able to reply
		t:curtask t:name@ reg!
		\ Set q to null on empty
		t:getq false q:throwing \ drop - why do I need to leave the q on stack else crashes immediately on running test
	;

	
	\ Response calls back here
	: w1
		a:open t:name@ "Response callback to: %s from %s with %d" s:strfmt log 
		ns:m pool-clear ns:a pool-clear
	;
	
	ns: somenamespace
	\ Called by REPL and response to REPL
	: w
		t:name@ "%s called w" s:strfmt log 
		1 a:@ swap 2 a:@ nip a:new 3 a:push t:name@ a:push response!
		ns:m pool-clear ns:a pool-clear
	;
	
	\ Create a number of tasks
	: create_task \ n --
		"Task-" swap >s s:+ gen_server_new
	;
	
	: create_tasks
		' create_task 1 100 loop drop
	;
	ns: user
	
	\ Terminate tasks
	: term_task \ n --
		"Task-" swap >s s:+ gen_server_term
	;

	: term_tasks
		' term_task 1 100 loop
	;
	
	\ Send messages and expect response
	: send_message	\ n --
		dup t:name@ "Task %s sending to %d" s:strfmt log 
		"Task-" swap >s s:+ ' somenamespace:w a:new 3 a:push ' w1 +sender msg!
		response@
	;
		
	: send_messages	\ n --
		' send_message 1 100 loop drop
		\ .stats
	;
	
	: repeat_messages	\ --
		' send_messages 1 10 loop
	;
	
	\ Main test
	set_q
	somenamespace:create_tasks
	repeat_messages
	term_tasks
	wait_all
	"Test complete" log
	bye
#then
	