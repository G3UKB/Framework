(* 
	gen_server.8th
 
  A general purpose server to be used for all tasks that require the
  messaging infrastructure.
 
 Copyright C 2019 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
     
  
  This module is loosly based on the erlang gen-server in that it emulates a 
	process oriented message passing concurrency model.
		
	This is part of the generic framework in the namespace fr.*
	
  PUBLIC INTERFACE:
  Main words for gen-server and message management:
  
  Create a new gen-server with the task name s. As everything is performed using the task name you should
  never need to get the task ref.
  
  	gen_server_new	SED: s --
  	
  Ask the gen-server with task name s to terminate. The server is designed to always allow proper termination.
  
  	gen_server_term SED: s --
  	
  Send a message to the gen-server with task name s, calling word w with the opaque data *. The opaque data can be
  any as it is passed directly to w. However, if a response is required the convention is [*, sender, w] where *
  is the opaque data and the sender is the task name to send the response to and w is the word to call [see later].
  
  	msg! SED: s w * --
  
  Retrieve message for tasks that are not gen-servers. Returns only data content.
  	msg@ SED: -- *
  	
  Retrieve message for tasks that are not gen-servers. Returns the whole message which includes response info.
  	msg@@ SED: -- *
  	
  A helper which will add the senders task name and word to call to the end of the array a, returning the new array.
  	+sender SED: a w -- a
  
  When the word w receives a message from msg! it must be aware of the structure of the opaque data and if a response
  is required the array must include the sender name and word to call. In order to respond it should call response! 
  with the sender name s, w|null the word to call with the response data and * the opaque response data.
  
  	response!	SED: s w * --
  
  Retrieve a response to a message for non-gen-server tasks.
  	
  	response@	SED: -- 
  
  Additional words for task registration and other utility actions:
  If a task which is NOT a gen-server wishes to participate in the messaging framework it must be registered in the task registry
  with t the task reference and s the task name.
  
  	reg!	SED: t s --
  
  Remove a registration.
  
  	reg_rm SED: s -- t
  	
  When it is required to terminate one or all tasks gen_server_term is used to terminate each task. However it is good practice 
  to wait for the task to exit.
  
  wait_single_task SED: s --
  Wait_all SED: --
 
 Messaging scenarios
 ===================
 There are quite a number of sender/receiver combinations that require specific protocols. These are pretty much the same
 whether messaging is direct through the gen-server or through the pub/sub system which dispatches through gen-server.
 However, the pub-sub system should be used for all communication unless there is a reason for not doing so. 
 
 \ non-GUI
 1. Sender : gen-server, receiver : gen-server. 
 		This is the simplest scenario as everything is managed by the gen-server. Messages are sent using msg!. If a response
 		task and word is included in the message then the response is automatically sent to the task using response!. Do not use msg!
 		to send a response as it will not work because the work needs to exit before msg! can be used.Note that both sending and
 		receiving are dispatched via the task-q so always arrive on the thread of the receiving task, not of the sending task.
 2. Sender : gen-server, receiver : normal user task.
 		In this case the normal user task must be registered using reg! so its task object can be retrieved by task name. Sending is 
 		the same as before using msg!. However, the receiver is not going to get that message automatically because there is no
 		gen-server to take it from the q. Therefore the receiver maust call msg@ or msg@@ to retrieve messages. It must do this
 		on a regular basis. There is no return value from the call, either the receiver word is called if there is a message or
 		nothing happens. If a response is required then the receiver can simply use msg! and the sender will automatically get the response.
 3. Sender : normal user task, receiver gen-server.
 		This is similar to [2]. The sender uses msg! As in [2] the receiver does not automatically get the message, it must use msg@ or 
 		msg@@. If a response is required then sender must call response@ as it will not automatically get the response. The usual place
 		top do that is immediately after msg!. Pre-requirements if it wants a response it must be registered and the user task must set
 		its task name with t:name! else +sender will get the default name and registry lookup will fail.
 4.	Sender : gen-server, receiver : REPL,MAIN-TASK task.
 		This is similar to [2] above except the main task is the recipient. As this is not a GUI task the message is dispatched as normal to
 		the task q and therefore must be retrieved with msg@ or msg@@.
 5. Sender : REPL,MAIN-TASK task, receiver : gen-server.
	 	Again similar to [3] above. The task uses msg! to send and if it wants to receive a reply it can use response@ to pick up the reply as
 		its not a gen-server.
 \ GUI
 6.	Sender : gen-server, receiver : GUI task.
  	This is similar to [2] above with the exception that the message is dispatched using g:do rather than to the message q. The message q 
  	and all synchronisation methods are inoperable in a GUI app. If the receiver wants to get a reply it can be sent by response! and will 
  	be automatically picked up by the gen-server task.
 7. Sender : GUI task, receiver : gen-server.
	 	Again similar to [3] above. The task uses msg! to send and if it wants to receive a reply then this is sent via g:do as its a GUI app. 
	 	The reply is picked up automatically.
*)

\ ========================================
\ Testing only
false var, gen_server_test_normal
true var, gen_server_test_gui

\ ----------------------------------
gen_server_test_normal @ #if
	\ Includes
	"E:/Projects/SDRLibEConsole/trunk/src/8th/harness/harness.8th" f:include
	\ needs debug/sed
	\ true SED-CHECK
	\ needs debug/trace
	\ dbg:line-info
#then
\ ----------------------------------
gen_server_test_gui @ #if
	\ Includes
	"E:/Projects/SDRLibEConsole/trunk/src/8th/harness/harness.8th" f:include
	\ needs debug/sed
	\ true SED-CHECK
	\ needs debug/trace
	\ dbg:line-info
#then
\ ========================================

\ Set namespace
ns: fr.gs

\ ===============================================================================
\ ===============================================================================
\ PRIVATE
\ Convention: private words start __
\ ===============================================================================

\ ========================================
\ Task reference and termination management

\ Holder for task references
\ Global var, requires lock semantics
{} var, __task_dict

\ ----------------------------------
\ Locked var
: __gs_lock@
	__task_dict lock @ ;

\ ----------------------------------
\ Unlocked var	
: __gs_unlock
	__task_dict unlock drop ;
	
\ ----------------------------------
\ Is locked	
: __gs_islocked
	__task_dict locked? nip ;

\ ----------------------------------	
\ Store task referance
: __gs_reg!	SED: t s --
	\ in: 	o: s - task name
	\				1: t - task object
	\ out:	none
	__gs_lock@
	swap rot m:! drop 
	__gs_unlock ;

\ ----------------------------------	
\ Get task referance
: __gs_reg@	SED: s -- t
	\ in: 	0: s - task name
	\ out:	0: t - task ref
	__gs_lock@
	swap m:@ nip 
	__gs_unlock ;

\ ----------------------------------	
\ Remove task referance
: __gs_reg_rm	SED: s -- t
	\ in: 	0: s - task name
	\ out:	none
	__gs_lock@
	swap m:- nip 
	__gs_unlock ;

\ ----------------------------------
\ Wait for task to terminate
: __gs_wait_task SED: s t --
	\ in:		t - task ref 	(item from dict) 	
	\				s - task name (key from dict)
	\ out:	none
	swap dup 
	t:name@ s:= not if
		\ Not the calling task, can't wait for ourselves!
		"Waiting for task: %s" s:strfmt log 
		t:wait
	else
		2drop
	then
;

\ ----------------------------------
\ Terminate task
\ This is called from the task to terminate itself
\ It sets the run task var to false which is then tested within gen_server
: __gs_do_term  SED: a --
	\ in: 	0: []
	\ out:	none
	drop false t:name@ "_run" s:+ t:!
;

\ ========================================
\ GEN-SERVER

\ Task exceptions should come here so 'maybe' we will know which task failed.
: __handler	SED: x -- rc
	t:name@ "Task %s handler called with [%s]" s:strfmt log
	\ We may be able to handle some exceptions by restarting task.
	\ Return 0 which means invoke G:handler which will terminate the program.
	0
;

\ ----------------------------------
\ Process 1 item from task Q	
: __gs_proc_q	SED: --
	t:qlen 0 n:= if
		"Warning gen-server queue was empty when processing [" t:name@ s:+ "]!" s:+ log 
	else 
		t:pop null? if
			drop "Warning gen-server queue returned null [" t:name@ s:+ "]!" s:+ log
		else
			\ Message to process, just send data part
			"data" m:@ swap "cb" m:@ nip w:exec
		then
	then ;
	
\ ----------------------------------
\ Task entry point for all generic servers
: __gen_server	 SED: s t -- 
	\ in: 	0 t: calling task
	\				1 s: this task name
	\ out:	none
	\ Assign name and store in registry
	>r dup t:name! t:curtask swap __gs_reg!
	"Created gen-server: " t:name@ s:+ log
	
	\ Set a task exception handler
	' __handler t:handler
	
	\ Set us in the run state using a task variable
	true t:name@ "_run" s:+ t:!
	
	\ Set q to return null on empty
	\ Note, should not happen
	t:getq false q:throwing drop
	\ Wake up calling thread which is waiting for us to finish initialisation
	r> t:notify
	\ We put 2 arbitrary items on stack. This allow us to check if the stack
	\ would cause an underflow which nearly always causes a crash and is therefore
	\ very hard to find.
	-1 -1
	\ Set initial depth limit to 3 (T + underflow items)
	3 "depth" t:!
	\ Loop while run enabled
	repeat
		\ Wait for a wake up notify
		-1 t:q-wait
		' __gs_proc_q t:qlen
		\ Check q length
		\ dup 1 n:> if "Q: " . t:qlen . cr cr then 
		times
		\ Check for exit
		t:name@ "_run" s:+ t:@
		\ Check for stack growth problem, only the T value and underflow items should be on stack at this point.
		depth "depth" t:@ n:> if
			"Task " t:name@ s:+ " warning - data stack growing [" s:+ depth 2 n:- >s s:+ "]!" s:+ log
			depth "depth" t:!
		then
		\ Check for stack underflow problem, we should always have two items on the stack.
		depth 2 n:< if
			"Task " t:name@ s:+ " fatal - data stack would cause underflow [" s:+ depth 2 n:- >s s:+ "]!" s:+ throw
		then
	while!
	\ Exit message
	t:name@ " - exiting... [" s:+ depth >s s:+ "]" s:+ log 2drop
;

\ ===============================================================================
\ ===============================================================================
\ PUBLIC Call level Interface
\ ===============================================================================

\ Make a new server
: gen_server_new	SED: s -- 
	\ in: 	0 s: new task name
	\ out:	none
	\ Create the new task
	t:curtask 2 ' __gen_server t:task-n
	\ Wait for it to complete registration
	-1 sleep drop
;

\ ----------------------------------
\ Register an external task
: reg@	SED: s -- t
	__gs_reg@ 
;
	
\ ----------------------------------
\ Register an external task
: reg!	SED: t s --
	__gs_reg! 
;

\ ----------------------------------
\ Remove an external task
: reg_rm	SED: s -- t
	__gs_reg_rm 
;

\ ----------------------------------
\ Wait for task to terminate
: wait_single_task	SED: s --
	dup >r "Waiting for task: " swap s:+ log
	__gs_lock@
	r@ m:@ t:wait
	r> m:-
	__gs_unlock drop 
;

\ ----------------------------------
\ Wait for all tasks to terminate
: wait_all	SED: --
	__gs_lock@
	' __gs_wait_task m:each
	1 sleep
	__gs_unlock 2drop 
;

\ ========================================
\ Message management
\ task-name task-name-to-check
: cmp_task	SED: s s -- T
	over s:= if true else false then
;

\ ----------------------------------
\ Message send to a given word on a given task name queue
: msg!	SED: s w * --
	\ in:		* - opaque data to send 	
	\				w - word to invoke in task
	\				s - task name
	\ out:	none
	\ Word to invoke under the "cb" key and data under the "data" key
	\ The data is cloned before the send as it must be detached from the current task pool
	2 pick >r
	m:new "cb" 3 pick m:! "data" 2 pick m:! nip nip
	\ Clone the whole message structure and push to the task q
	const
	\ Get task for name and lock task-dict
	swap __gs_lock@ 
	swap m:@ nip
	\ Check message destination
	dup rot  \ task data
	\ Check if we running a GUI app
	app:isgui @ if
		\ Yes, so check the target
		r> ["REPL" , "GUI", "MAIN-TASK"] ' cmp_task a:filter nip a:len nip 0 n:> if 
			\ The destination is a main-task so we must use g:do
			\ task data {"cb": w, "data":[value, sender]}
			g:do
		else
			\ Not a GUI app so we can dispatch to a q regardless
			t:push t:q-notify
		then
	else
		\ User task or gen-server so push message to task q 
		t:push t:q-notify
	then
	\ Release lock
	__gs_unlock drop
;

\ ----------------------------------
\ Add sender to message
: +sender	SED:	a w -- a
	\ in: 	0: w - word to call on response
	\				1: a - message array [*]
	\ out: 	0: a - [*, sender task name, w]
	swap t:name@ a:push swap a:push
;

\ ----------------------------------
\ Pull and execute from a task q else do nothing
\ Useful for non gen-server tasks which use pub/sub
: msg@	SED: -- *
	\ Check for a message
	t:qlen 0 n:> if 
		t:pop null? not if
			\ We have work
			\ Just send the data part of the message
			"data" m:@ 0 a:@ nip swap "cb" m:@ nip w:exec
		then
	then
;
\ As msg@ but return whole message
: msg@@	SED: -- *
	\ Check for a message
	t:qlen 0 n:> if 
		t:pop null? not if
			\ We have work
			\ Send the whole message which has the sender/word for responses
			"data" m:@ swap "cb" m:@ nip w:exec
		then
	then
;

\ ========================================
\ Response management

\ ----------------------------------
\ Get task response for synchronous send/response
: response@	SED: -- 
	\ in: 	none
	\ out: 	0: * - opaque response data
	\ Spin a while as we won't get a notify 
	100 repeat
		t:pop null? if
			\ Keep going
			drop n:1- 0.01 sleep
		else
			\ Data to process
			nip "data" m:@ swap "cb" m:@ nip w:exec ;;
		then
	while drop	
	"Timeout waiting for task response!" log
;

\ ----------------------------------
\ Push response data to sender
: __responder msg! ;
: response!	SED: s w * --
	\ in:		* - opaque data to send 	
	\				w - word to invoke in task
	\				s - task name
	\ out:	none
	\ We send response via a transient task otherwise we would deadlock
	const 3 ' __responder t:task-n t:wait
;

\ ----------------------------------
\ Chck for response data
\ respnse-array -- task-name word flag
: __is_response? SED: a -- s w T
	a:len 3 n:= if
		a:open null? if
			false
		else
			true
		then
	then
;

\ ========================================
\ Task termination
\ ----------------------------------
\ Ask task to terminate
: gen_server_term SED: s --
	\ We send an empty message to __gs_do_term which will self terminate
	' __gs_do_term a:new msg!
;

\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ ===============================================================================
\ Testing
\ ===============================================================================

\ ===============================================================================
\ non-GUI tests

gen_server_test_normal @ #if
	with: fr.gs
	
	\ The functional tests execute each scenario as given in the docs intro.
	\ Words called by messaging system
	
	\ ========================================
	\ Scenario 1: sender: gen-server, receiver: gen-server
	: s1_gs1_response
		t:name@ "%s received response %s" s:strfmt log
	;
	: s1_gs1_receive
		t:name@ "%s received message %s" s:strfmt log
	;
	: s1_gs2_receive
		dup t:name@ "%s received message %s" s:strfmt log
		\ Test for response data
		__is_response? if
			\ Good response data with a valid word to invoke
			["Response from GS-2"] response!
		then
	;
	: s1_repl_receive
		\ Initial receive to kick off exchanges between GS-1 and GS-2
		t:name@ "%s received message %s" s:strfmt log
		\ We are now in GS-1 so we can send a message to GS-2
		\ The message must be an array
		"GS-2" ' s1_gs2_receive ["Hi from GS-1"] msg!
		\ Now one that requirs a reply
		\ Here the message array is augmented with a task name and word to respond to.
		"GS-2" ' s1_gs2_receive ["Hi from GS-1"] ' s1_gs1_response +sender msg!
	;	
	: scenario-1
		"*********Scenario 1 *********" log
		\ Create two gen-servers
		\ Note that we get nothing back, simply use the name to communicate
		\ Also as this is not a GUI task yet we can create these on the main thread
		"GS-1" gen_server_new
		"GS-2" gen_server_new
		\ Send a message from REPL to GS-1 to start things rolling
		"GS-1" ' s1_repl_receive ["Hi from REPL"] msg!
		1 sleep
		"GS-1" gen_server_term
		"GS-2" gen_server_term
	;
	\ ========================================
	
	\ ========================================
	\ Scenario 2 sender: gen-server, receiver: user task
	: s2_gs1_response
		t:name@ "%s received response %s" s:strfmt log
	;
	: s2_gs2_receive
		dup t:name@ "%s received message %s" s:strfmt log
		\ Test for response data
		__is_response? if
			\ Good response data with a valid word to invoke
			["Response from GS-2"] response!
		then
	;
	: s2_task_response
			t:name@ "%s received response %s" s:strfmt log
	;
	: s2_task_receive
		dup t:name@ "%s received message %s" s:strfmt log
		\ Test for termination
		0 a:@ "term" s:= if true "t1" t:! then 
		\ Test for response data
		__is_response? if
			\ Good response data with a valid word to invoke
			["Response from T-1"] response!
		then
	;
	: s2_task
		"T-1" t:name!
		t:name@ "%s running" s:strfmt log
		false "t1" t:!
		repeat
			"t1" t:@ if break then
			msg@@
			0.1 sleep
		again
		t:name@ "%s exiting" s:strfmt log
	;
	: s2_repl_receive
		\ Initial receive to kick off exchanges between GS-1 and T-1
		t:name@ "%s received message %s" s:strfmt log
		\ We are now in GS-1 so we can send a message to T-1
		\ The message must be an array
		"T-1" ' s2_task_receive ["Hi from GS-1"] msg!
		\ Now one that requirs a reply
		\ Here the message array is augmented with a task name and word to respond to.
		"T-1" ' s2_task_receive ["Hi from GS-1"] ' s2_gs1_response +sender msg!
	;	
	: scenario-2
		"*********Scenario 2 *********" log
		\ Create one gen-server and one task
		\ Note that we get nothing back, simply use the name to communicate
		\ Also as this is not a GUI task yet we can create this on the main thread
		"GS-1" gen_server_new
		\ Create user task and register it
		' s2_task t:task "T-1" reg!
		\ Send a message from REPL to GS-1 to start things rolling
		"GS-1" ' s2_repl_receive ["Hi from REPL"] msg!
		1 sleep
		"GS-1" gen_server_term
		"T-1" ' s2_task_receive ["term"] msg!
	;
	\ ========================================
	
	\ ========================================
	\ Scenario 3 sender: user task, receiver: gen-server
	: s3_gs1_response
		t:name@ "%s received response %s" s:strfmt log
	;
	: s3_gs1_receive
		dup t:name@ "%s received message %s" s:strfmt log
		\ Test for response data
		__is_response? if
			\ Good response data with a valid word to invoke
			["Response from GS-2"] response!
		then
	;
	: s3_task_response
			t:name@ "%s received response %s" s:strfmt log
	;
	: s3_task_receive
		dup t:name@ "%s received message %s" s:strfmt log
		\ Test for termination
		0 a:@ "term" s:= if true "t1" t:! then 
		\ Test for response data
		__is_response? if
			\ Good response data with a valid word to invoke
			["Response from T-1"] response!
		then
	;
	: s3_task
		\ Must set task name else +sender will get the defult name and lookup will fail.
		"T-1" t:name!
		t:name@ "%s running" s:strfmt log
		\ Don't throw
		t:getq false q:throwing drop
		false "t1" t:!
		repeat
			"t1" t:@ if break then
			msg@@
			0.1 sleep
		again
		t:name@ "%s exiting" s:strfmt log
	;
	: s3_repl_receive
		\ Initial receive to kick off exchanges between T-1 and GS-1
		t:name@ "%s received message %s" s:strfmt log
		\ We are now in T-1 so we can send a message to T-1
		\ The message must be an array
		"GS-1" ' s3_gs2_receive ["Hi from T-1"] msg!
		\ Now one that requirs a reply
		\ Here the message array is augmented with a task name and word to respond to.
		"GS-1" ' s3_gs1_receive ["Hi from T-1"] ' s3_task_response +sender msg! response@
	;	
	: scenario-3
		"*********Scenario 3 *********" log
		\ Create one gen-server and one task
		\ Note that we get nothing back, simply use the name to communicate
		\ Also as this is not a GUI task yet we can create this on the main thread
		"GS-1" gen_server_new
		\ Create user task and register it
		' s3_task t:task "T-1" reg!
		\ Send a message from REPL to T-1 to start things rolling
		"T-1" ' s3_repl_receive ["Hi from REPL"] msg!
		1 sleep
		"GS-1" gen_server_term
		"T-1" ' s3_task_receive ["term"] msg!
	;
	\ ========================================
	
	\ ========================================
	\ Scenario 4 : Sender : gen-server, receiver : REPL,MAIN-TASK task
	: s4_main_receive
		t:name@ "%s received message %s" s:strfmt log
		true "main" t:!
	;
	: s4_gen_server
		t:name@ "%s received message %s" s:strfmt log
		\ Message MAIN_TASK
		"MAIN_TASK" ' s4_main_receive ["Hi from GS-1"] msg!
	;
	\ We have to create gen-servers in a task for a GUI app.
	\ Not necessary if it isn't but we do it anyway as this will be the normal use case.
	: s4_task
		"T-1" t:name!
		t:name@ "%s running" s:strfmt log
		\ Don't throw
		t:getq false q:throwing drop
		\ Make the gen-server
		"GS-1" gen_server_new
		\ Kick the gen-server off
		"GS-1" ' s4_gen_server ["Hi from T-1"] msg!
		1 sleep
		"GS-1" gen_server_term
		"T-1" ' s3_task_receive ["term"] msg!
	;
	
	: scenario-4
		"*********Scenario 4 *********" log
		\ Create user task and register it
		' s4_task t:task "T-1" reg!
		\ Register the main task so we can communicate
		t:curtask "MAIN_TASK" dup t:name! reg!
		false "main" t:!
		repeat
			"main" t:@ if break then
			msg@@
			0.1 sleep
		again
		"MAIN-TASK exiting" log
	;
	\ ========================================
	
	\ ========================================
	\ Scenario 5 : Sender : REPL,MAIN-TASK task, receiver : gen-server
	
	\ ========================================
	: app:main
		scenario-1
		1 sleep
		scenario-2
		1 sleep
		scenario-3
		1 sleep
		scenario-4
		1 sleep
		"********* Test Complete *********" log
		1 sleep
		bye
	;
#then

\ ===============================================================================
\ GUI  tests

gen_server_test_gui @ #if
	with: fr.gs	
	with: harness
	\ ========================================
	\ Scenario 6 : Sender : gen-server, receiver : GUI task
	: s6_main_receive
		t:name@ "%s received message %s" s:strfmt log
		true "main" t:!
	;
	: s6_gen_server
		t:name@ "%s received message %s" s:strfmt log
		\ Message MAIN-TASK
		"MAIN-TASK" ' s6_main_receive ["Hi from GS-1"] msg!
	;
	\ We have to create gen-servers in a task for a GUI app.
	: s6_task
		"T-1" t:name!
		t:name@ "%s running" s:strfmt log
		\ Don't throw
		t:getq false q:throwing drop
		\ Make the gen-server
		"GS-1" gen_server_new
		\ Kick the gen-server off
		"GS-1" ' s6_gen_server ["Hi from T-1"] msg!
		1 sleep
		"GS-1" gen_server_term
		"T-1" ' s6_task_receive ["term"] msg!
	;
	
	: scenario-6
		"*********Scenario 6 *********" log
		\ Create user task and register it
		' s6_task t:task "T-1" reg!
		\ Register the main task so we can communicate
		t:curtask "MAIN-TASK" dup t:name! reg!
		\ Create a window so we can exit the test
		harness_window
		"MAIN-TASK exiting" log
	;
	\ ========================================
	
	\ ========================================
	\ Scenario 7 : Sender :  GUI task, receiver : gen-server
	
	\ ========================================
	true app:isgui !
	: app:main
		scenario-6
	;
	
#then
	