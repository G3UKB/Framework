(* 
	pub_sub.8th
 
  Publish/Subscribe system
 
 Copyright C 2019 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
     
  The public interface can be called from any task.
  Subscribers subscribe to a topic and provide a task name and a word to call.
  Publishers publish to a topic with data to send via a gen-server. There are no
  direct calls. All data is sent via messages to the subscribing tasks.
  
  Note that this should be used for one way calls although there is nothing to
  prevent a reply by agreement between sender and receiver [see gen_server].
  
  PUBLIC INTERFACE:
	  
  	Subscribe to a topic where s is the task name of the target task and w is the
  	word to call in the target task and s is the topic to subscribe to. Topic names
  	and task names are strings. Note that there is no registration of topics, if a 
  	topic does not exist it will be created.
  	
  		subscribe	SED: s w s --
  	
  	Publish to a topic where * is the opaque data to send and s is the topic name. 
  	If a topic does not exist a message will be logged but it won't fail.
  	Subscribers should therefore subscribe before publishing starts. Note that this
  	is asynchronous as publish will return once messages have been sent to all subscribers.
  	
  		publish	SED: * s --
  	
*)

needs stack/3drop

\ ========================================
\ Testing only
true var, pub_sub_test

\ ----------------------------------
pub_sub_test @ #if
	\ Includes
	"gen_server.8th" f:include
	\ needs debug/sed
	\ true SED-CHECK
	\ dbg:line-info
#then

\ ========================================
\ Set namespace
ns: fr.ps
with: fr.gs

\ ===============================================================================
\ ===============================================================================
\ PRIVATE
\ Convention: private words start __
\ ===============================================================================

\ ========================================
\ Topic/Subscriber reference

\ Holder for subscriber references
\ Global var, requires lock semantics
{} var, __ps

\ ----------------------------------
\ Locked var
: __ps_lock@	SED: -- m
	__ps lock @ ;

\ ----------------------------------
\ Unlocked var	
: __ps_unlock	SED: --
	__ps unlock drop ;
	
\ ----------------------------------
\ Is locked	
: __ps_islocked	SED: -- T
	__ps locked? nip ;

\ ========================================
\ Dispatcher
\ Dispatch to a subscriber
: __dispatcher	SED: * a -- *
	\ in:		a - [task-name, w] 	
	\				* - opaque data to send
	\ out:	none
	a:open 	\ * task-name w
	\ Do not dispatch if the publisher is also the subscriber
	1 pick dup t:name@ s:= not if
	 \ Test for dispatch type
	 {"REPL":1 , "GUI":1} swap m:exists? nip if
			\ Can't message to a Q, so dispatch via g:do
			m:new "cb" rot m:! 2 pick "data" swap m:! g:do drop
		else
			\ A task, so dispatch via normal messaging
			rot msg!
		then
	else
		\ Just clean up
		3drop
	then
;
	
\ ===============================================================================
\ ===============================================================================
\ PUBLIC Call level Interface
\ ===============================================================================

\ ----------------------------------
\ Subscribe to a topic	
: subscribe	SED: s w s --
	\ in:		s - topic to subscribe to 	
	\				w - word to invoke in task
	\				s - task name to publish to
	\ out:	none
	__ps_lock@ 
	1 pick m:exists? not if	\ t-name word topic ps
		\ Topic does not exist so create
		a:new 4 pick a:push 3 pick a:push	\ t-name word topic ps [t-name, w]
		a:new swap a:push	\ t-name word topic ps [[t-name, w]]
		swap 2 pick rot m:!	\ t-name word topic ps
	else
		\ Topic exists
		1 pick m:@ \ t-name word topic ps [[t-name, w], ...]
		a:new 5 pick a:push 4 pick a:push \ t-name word topic ps [[t-name, w], ...] [t-name, w]
		a:push \ t-name word topic ps [[t-name, w], ... , [t-name, w]] 
	then
	__ps_unlock
	2drop 2drop
;

\ ----------------------------------
\ Publish to a topic	
: publish	SED: * s --
	\ in:		s - topic to publish to 	
	\				* - opaque data to send
	\ out:	none	
	__ps_lock@ 
	1 pick m:exists? not if
		\ No such topic
		1 pick "Topic %s does not exist - ignoring" s:strfmt log 2drop
	else
		1 pick m:@ nip nip ' __dispatcher a:each!
	then
	__ps_unlock
	drop
;	
	
\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ ===============================================================================
\ Testing
\ ===============================================================================

pub_sub_test @ #if
	(*
		For a minimal test:
		1. Have words that receive published messages and print the data.
		2. Have words that subscribe to a topic.
		3. Have words that publish to a topic.
		4. Create n gen-servers.
		5. Send a message via each gen-server to words in 2.
		6. Send a message via each gen-server to words in 3.
		7. The words in 1 should receive the messages inless publisher == subscriber.
	*)
	
	with: fr.gs
	with: fr.ps
	
	\ Receivers
	: receiver1	SED: * --
		"Called receiver1 with %s" s:strfmt log
	;
	
	: receiver2	SED: * --
		"Called receiver2 with %s" s:strfmt log
	;
	
	: receiver3	SED: * --
		"Called receiver3 with %s" s:strfmt log
	;
		
	: receiver4	SED: * --
		"Called receiver4 with %s" s:strfmt log
	;
	
	\ Subscribers
	: subscriber1 SED: * --
		drop t:name@ ' receiver1 "Topic-1" subscribe
	;
	
	: subscriber2 SED: * --
		drop t:name@ ' receiver2 "Topic-2" subscribe
	;
	
	: subscriber3 SED: * --
		drop t:name@ ' receiver3 "Topic-3" subscribe
	;
		
	: subscriber4 SED: * --
		drop t:name@ ' receiver4 "Topic-4" subscribe
	;
	\ Both to same topic
	: subscriber1.1 SED: * --
		drop t:name@ ' receiver1 "Topic-1" subscribe
	;

	: subscriber1.2 SED: * --
		drop t:name@ ' receiver2 "Topic-1" subscribe
	;
	
	\ Publishers
	: publisher1 SED: * --
		drop "Data-1" "Topic-1" publish
	;
		
	: publisher2 SED: * --
		drop "Data-2" "Topic-2" publish
	;
	
	: publisher3 SED: * --
		drop "Data-3" "Topic-3" publish
	;
			
	: publisher4 SED: * --
		drop "Data-4" "Topic-4" publish
	;	
	
	\ This subscriber will be on the main thread
	: reg_task
		\ Must register REPL in the task repos to be able to reply
		t:curtask t:name@ reg!
		\ Set q to null on empty
		t:getq false q:throwing \ do not drop q else crashes
	;
	
	: main_thrd_receiver	SED: * --
		"Called main_thrd_receiver with %s" s:strfmt log
	;
	
	: main_thrd_subscriber SED:  --
		t:name@ ' main_thrd_receiver "Topic-1" subscribe
	;
	
	: runtest
		\ Create tasks
		"Task-1" gen_server_new
		"Task-2" gen_server_new
		"Task-3" gen_server_new
		"Task-4" gen_server_new
		"Task-5" gen_server_new
		"Task-6" gen_server_new
		"Task-7" gen_server_new
		"Task-8" gen_server_new
		\ Subscribe
		\ Register main  task
		reg_task
		\ and subscribe from main thread
		main_thrd_subscriber
		\ Task subscriptions
		"Task-1" ' subscriber1 null msg!
		"Task-2" ' subscriber2 null msg!
		"Task-3" ' subscriber3 null msg!
		"Task-4" ' subscriber4 null msg!
		1 sleep
		\ Publish
		\ These will not call subscribers as publisher == subscriber
		\ Except Task-1 which will publish to REPL via g:do as well as Task-1
		"Task-1" ' publisher1 null msg!
		"Task-2" ' publisher2 null msg!
		"Task-3" ' publisher3 null msg!
		"Task-4" ' publisher4 null msg!
		\ These will call subscribers
		"Task-5" ' publisher1 null msg!
		"Task-6" ' publisher2 null msg!
		"Task-7" ' publisher3 null msg!
		"Task-8" ' publisher4 null msg!
		1 sleep
		\ Close servers
		"Task-1" gen_server_term
		"Task-2" gen_server_term
		"Task-3" gen_server_term
		"Task-4" gen_server_term
		"Task-5" gen_server_term
		"Task-6" gen_server_term
		"Task-7" gen_server_term
		"Task-8" gen_server_term
		1 sleep
		\ Wait for completion
		wait_all  
		"Test complete" log
		1 sleep
	;
	
	runtest
	bye
	
#then
	