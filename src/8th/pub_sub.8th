(* 
	pub_sub.8th
 
  Publish/Subscribe system
 
 Copyright C 2019 by G3UKB Bob Cowdery
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 at your option any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
  The author can be reached by email at:   
     bob@bobcowdery.plus.com
  
  -----------------------------------------------------------------------------
  The publish/subscribe system is a layer on top of gen_server. It should be the
  primary means of communication between tasks and within tasks. It's a thin layer
  but provides a level of abstraction so senders and receivers are decoupled.
  
  The public interface can be called from any task.
  Subscribers subscribe to a topic and provide a task name and a word to call.
  Publishers publish to a topic with data to send via a gen-server msg!. There are no
  direct calls. All data is sent via messages to the subscribing tasks.
  
  PUBLIC INTERFACE:
	  
  	Subscribe to a topic where s is the task name of the target task and w is the
  	word to call in the target task and s is the topic to subscribe to. Topic names
  	and task names are strings. Note that there is no registration of topics, if a 
  	topic does not exist it will be created.
  	
  		subscribe	SED: s w s --
  	
  	Publish to a topic where * is the opaque data to send and s is the topic name. 
  	If a topic does not exist a message will be logged but it won't fail.
  	Subscribers should therefore subscribe before publishing starts. Note that this
  	is asynchronous as publish will return once messages have been sent to all subscribers.
  	
  		publish	SED: * s --
  	
*)

needs stack/3drop

\ ========================================
\ Testing only
true var, pub_sub_test

\ ----------------------------------
pub_sub_test @ #if
	\ Includes
	"E:/Projects/SDRLibEConsole/trunk/src/8th/harness/harness.8th" f:include
	"gen_server.8th" f:include
	\ needs debug/sed
	\ true SED-CHECK
	\ dbg:line-info
#then

\ ========================================
\ Set namespace
ns: fr.ps
with: fr.gs

\ ===============================================================================
\ ===============================================================================
\ PRIVATE
\ Convention: private words start __
\ ===============================================================================

\ ========================================
\ Topic/Subscriber reference

\ Holder for subscriber references
\ Global var, requires lock semantics
{} var, __ps

\ ----------------------------------
\ Locked var
: __ps_lock@	SED: -- m
	__ps lock @ ;

\ ----------------------------------
\ Unlocked var	
: __ps_unlock	SED: --
	__ps unlock drop ;
	
\ ----------------------------------
\ Is locked	
: __ps_islocked	SED: -- T
	__ps locked? nip ;

\ ========================================
\ Dispatcher
\ Dispatch to a subscriber
: __dispatcher	SED: * a -- *
	\ in:		a - [task-name, w] 	
	\				* - opaque data to send
	\ out:	none
	a:open 	\ * task-name w
	\ May need to enhance this as I think there is a possibility of creating a loop. In
	\ particular a GUI may publish off an event but may also subscribe to the same event.
	\ For example a user click tunes on a panadapter. This generates a freq event which several
	\ other GUI elements subscribe to. We have to be sure we don't mistake the update for something
	\ we need to propogate, thus creating a loop. It may be hard to guard against this.
	\ Dispatch to msg!. If this needs to be a g:do that is handled by the gen-server.
	2 pick msg!
;
	
\ ===============================================================================
\ ===============================================================================
\ PUBLIC Call level Interface
\ ===============================================================================

\ ----------------------------------
\ Subscribe to a topic	
: subscribe	SED: s w s --
	\ in:		s - topic to subscribe to 	
	\				w - word to invoke in task
	\				s - task name to publish to
	\ out:	none
	__ps_lock@
	1 pick m:exists? not if \ t-name word topic ps
		\ Topic does not exist so create
		a:new 4 pick a:push 3 pick a:push \ t-name word topic ps [t-name, w]
		a:new swap a:push \ t-name word topic ps [[t-name, w]]
		swap 2 pick rot m:! \ t-name word topic ps
	else
		\ Topic exists
		1 pick m:@ \ t-name word topic ps [[t-name, w], ...]
		a:new 5 pick a:push 4 pick a:push \ t-name word topic ps [[t-name, w], ...] [t-name, w]
		a:push \ t-name word topic ps [[t-name, w], ... , [t-name, w]] 
	then
	__ps_unlock
	2drop 2drop
;

\ ----------------------------------
\ Publish to a topic	
: publish	SED: * s --
	\ in:		s - topic to publish to 	
	\				* - opaque data to send
	\ out:	none
	__ps_lock@ 
	1 pick m:exists? not if
		\ At this point it is an error
		1 pick "No subscribers for topic %s!" s:strfmt log drop
	else
		1 pick m:@ nip nip ' __dispatcher a:each!
	then
	__ps_unlock
	drop
;

\ ========================================
\ Indirect publish
\ Called by the gen-server to complete the publish
: __publish SED: a --
	a:open publish
;

\ Publish via the gen-server task
: publish!	SED: * s --	
	2 a:close "PUB-SUB-TASK" ' __publish rot msg!
;

\ ----------------------------------
: pubsub_init	SED: --
	\ We create a gen-server to use to publish when we cannot do so directly.
	\ This occurs e.g. when we are in a GUI callback and we want to publish something
	\ that could call back into the GUI task. This would lock the event loop.
	"PUB-SUB-TASK" gen_server_new
;

\ ----------------------------------
: pubsub_term	SED: --
	\ We create a gen-server to use to publish when we cannot doso directly
	\ This occurs e.g. when we are in a GUI callback and we want to publish something
	\ that could call back into the GUI task which would not be allowed.
	"PUB-SUB-TASK" gen_server_term
;

\ ========================================
\ Reset namespace
ns: user

\ ===============================================================================
\ ===============================================================================
\ Testing
\ ===============================================================================

pub_sub_test @ #if
	with: fr.gs
	with: fr.ps
	with: harness
	
	(*
		This is a layer ontop on gen-server and therefore has the same set of rules that
		apply to direct communication via gen-server and its associated words.
		
		We test this by creating the set of possible sources and sinks and then create a 
		matrix of one-way messages. We then repeat with responses.
		
		We will nearly always be working with a GUI app so the tests assume this environment.
		
		1. Create a gen-server GS-1 and a user-task UT-1.
		2. Subscribe to TOPIC-1 from MAIN-TASK, GS-1 and UT-1.
		3. Subscribe to TOPIC-2 from from MAIN-TASK, GS-1 and UT-1.
		4. Subscribe to TOPIC-3 from from MAIN-TASK, GS-1 and UT-1.
		5. Publish TOPIC-2 from UT-1.
		6. Publish TOPIC-3 from GS-1. 
		7. From a GUI button click publish! TOPIC-1, 2 and 3.
	*)
	
	\ ========================================
	\ Gen-server subscription words
	: gs1_task_subs_1
		t:name@ "TOPIC-1" "%s: %s received message: %s" s:strfmt log
	;
	: gs1_task_subs_2
		t:name@ "TOPIC-2" "%s: %s received message: %s" s:strfmt log
	;
	: gs1_task_subs_3
			t:name@ "TOPIC-3" "%s: %s received message: %s" s:strfmt log
	;
	: gs1_subscribe
		"GS-1" ' gs1_task_subs_1 "TOPIC-1" subscribe
		"GS-1" ' gs1_task_subs_2 "TOPIC-2" subscribe
		"GS-1" ' gs1_task_subs_3 "TOPIC-3" subscribe
	;
	: gs1_publish
		"GS-1 task data" "TOPIC-3" publish
	;
	
	\ ========================================
	\ User task subscription words
	: ut1_task_subs_1
		t:name@ "TOPIC-1" "%s: %s received message: %s" s:strfmt log
	;
	: ut1_task_subs_2
		t:name@ "TOPIC-2" "%s: %s received message: %s" s:strfmt log
	;
	: ut1_task_subs_3
		t:name@ "TOPIC-3" "%s: %s received message: %s" s:strfmt log
	;
	: ut1_term
		true "user-task" t:!
	;
	
	\ ========================================
	\ Normal user task for communication
	: user_task
		"UT-1" t:name!
		t:name@ "%s running" s:strfmt log
		\ Don't throw
		t:getq false q:throwing drop
		"UT-1" ' ut1_task_subs_1 "TOPIC-1" subscribe
		"UT-1" ' ut1_task_subs_2 "TOPIC-2" subscribe
		"UT-1" ' ut1_task_subs_3 "TOPIC-3" subscribe
		2 sleep
		"User task data" "TOPIC-2" publish
		"GS-1" ' gs1_publish null msg!
		false "user-task" t:!
		repeat
			"user-task" t:@ if break then
			msg@@
			0.1 sleep
		again
		"UT-1 exiting" log
	;
	
	\ ========================================
	\ We have to create gen-servers in a task for a GUI app.
	: startup_task
		"STARTUP" t:name!
		t:name@ "%s running" s:strfmt log
		\ Don't throw
		t:getq false q:throwing drop
		\ Init pubsub system
		pubsub_init
		\ Make a gen-server
		"GS-1" gen_server_new
		"GS-1" ' gs1_subscribe null msg!
		\ Make a normal user task
		' user_task t:task "UT-1" reg!
	;
	
	\ ========================================
	\ GUI task events
	: button_clicked
		 "Button-clicked data" "TOPIC-1" publish!
		 "Button-clicked data" "TOPIC-2" publish!
		 "Button-clicked data" "TOPIC-3" publish!
	;
	
	\ ========================================
	\ GUI task subscriber words
	: gui_subs_1
		t:name@ "TOPIC-1" "%s: %s received message: %s" s:strfmt log
	;
	: gui_subs_2
		t:name@ "TOPIC-2" "%s: %s received message: %s" s:strfmt log
	;
	: gui_subs_3
		t:name@ "TOPIC-3" "%s: %s received message: %s" s:strfmt log
	;
	
	\ ========================================
		\ Termination
	: terminate
		false log-async
		"UT-1" ' ut1_term null msg!
		0.1 sleep
		pubsub_term
		0.1 sleep
		"GS-1" gen_server_term
		wait_all
		1 sleep
	;
	
	\ ========================================
	\ Main script
	: script
		"********* Pub/Sub matrix test *********" log
		\ Create user task and register it
		' startup_task t:task "STARTUP" reg!
		\ Register the main task so we can communicate
		t:curtask "MAIN-TASK" dup t:name! reg!
		\ Create a window with one button
		harness_window
		1 sleep
		\ Do GUI task subscriptions
		"MAIN-TASK" ' gui_subs_1 "TOPIC-1" subscribe
		"MAIN-TASK" ' gui_subs_2 "TOPIC-2" subscribe
		"MAIN-TASK" ' gui_subs_3 "TOPIC-3" subscribe
		\ Set closedown
		' terminate onexit
	;
	
	\ ========================================
	true app:isgui !
	: app:main
		script
		"app:main exiting" log
	;
#then	
